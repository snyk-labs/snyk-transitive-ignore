"use strict";
//export {}
Object.defineProperty(exports, "__esModule", { value: true });
//import 'source-map-support/register'
const args = require('minimist')(process.argv.slice(2));
const fs_1 = require("fs");
const debugLib = require("debug");
const debug = debugLib('snyk:index');
const IGNORE_FILE = ".snyk_ignore";
function readStream(stream, encoding = "utf8") {
    return new Promise((resolve, reject) => {
        let data = "";
        stream.on("data", chunk => data += chunk);
        stream.on("end", () => resolve(data));
        stream.on("error", error => reject(error));
    });
}
function checkIgnoreListMatch(ignoreItems, directDep) {
    // check for two types of matches
    // 1. when version is not specified in the ignore entry
    // 2. when version is specified in the ignore entry
    for (const ignoreItem of ignoreItems) {
        if (ignoreItem.length > 0) {
            debug('ignore item: ' + ignoreItem);
            // if ignoreItem contains an @ symbol, compare for equality to directDep
            if (ignoreItem.includes('@') && !ignoreItem.startsWith('@')) {
                debug('ignore includes version');
                if (ignoreItem == directDep) {
                    debug(`${ignoreItem} matches ${directDep}`);
                    return true;
                }
            }
            // if ignoreItem does not contain an @symbol, compare for startsWith match
            // up to and including @ symbol (any version)
            else {
                debug('ignore does not include version');
                if (ignoreItem.includes('*') && !ignoreItem.startsWith('*')) {
                    debug('ignore includes *');
                    if (directDep.startsWith(ignoreItem.slice(0, -1))) {
                        debug(`${ignoreItem} matches ${directDep}`);
                        return true;
                    }
                }
                if (directDep.startsWith(ignoreItem.concat('@'))) {
                    debug(`${ignoreItem} matches ${directDep}`);
                    return true;
                }
            }
        }
    }
    return false;
}
function writeIgnoreEntry(vuln, path, expires, reason) {
    let writeString = "ignore:\n" +
        "  " + vuln + ":\n" +
        "    - '" + path + "':\n" +
        "        reason: " + reason + "\n" +
        "        expires: " + expires + "\n";
    fs_1.writeFileSync(IGNORE_FILE, writeString, { flag: 'a' });
}
async function snykTransitiveIgnore() {
    var inputFile = "";
    var fullPath = "";
    var ignoreRules = [];
    var nestingLevel = 1;
    var ignorePath = "";
    fs_1.writeFileSync(IGNORE_FILE, "#snyk ignore file generated by snyk-transitive-ignore", { flag: 'w' });
    if (args.f && typeof args.f !== 'boolean') {
        inputFile = args.f;
        var ignoreStrings = await fs_1.readFileSync(inputFile).toString().split("\n");
        debug('ignore strings: ' + ignoreStrings);
    }
    else {
        console.log('input file not specified');
    }
    if (args.l && typeof args.l !== 'boolean') {
        nestingLevel = args.l;
        //console.log(ignoreStrings);
    }
    await readStream(process.stdin).then(async function (data) {
        const issues = JSON.parse(String(data));
        for await (const vuln of issues.vulnerabilities) {
            fullPath = "";
            debug(`vuln id ${vuln.id}`);
            debug(`from direct dep ${vuln.from[nestingLevel]}`);
            for await (const from of vuln.from) {
                if (fullPath != "") {
                    fullPath += ` > ${from}`;
                }
                else {
                    fullPath = `${from}`;
                }
            }
            debug(`full path ${fullPath}`);
            debug(`is ${vuln.from[nestingLevel]} in ignore list?`);
            if (checkIgnoreListMatch(ignoreStrings, vuln.from[nestingLevel])) {
                debug('checkIgnore -> true');
                //await writeIgnoreEntry(vuln.id, vuln.from[1], "2100-01-01", "transitive ignore")
                if (nestingLevel > 1) {
                    //build ignore path
                    ignorePath = ""
                    var i = 1;
                    while (i < nestingLevel) {
                        ignorePath = ignorePath + vuln.from[i] + " > " + vuln.from[i + 1];
                        i++;
                    }
                }
                else {
                    ignorePath = vuln.from[1];
                }
                ignoreRules.push({
                    vulnId: vuln.id,
                    //path: vuln.from[nestingLevel]
                    path: ignorePath
                });
            }
        }
        var issuesToIgnore = {};
        for await (const ignoreRule of ignoreRules) {
            debug(ignoreRule.vulnId);
            debug(ignoreRule.path);
            if (issuesToIgnore[ignoreRule.vulnId]) {
                if (!issuesToIgnore[ignoreRule.vulnId].includes(ignoreRule.path)) {
                    issuesToIgnore[ignoreRule.vulnId].push(ignoreRule.path);
                }
            }
            else {
                issuesToIgnore[ignoreRule.vulnId] = [ignoreRule.path];
            }
        }
        console.log('issues to ignore:');
        console.log(issuesToIgnore);
        // loop through issuesToIgnore and write ignore Entries
        fs_1.writeFileSync(IGNORE_FILE, "ignore:\n");
        for (let key in issuesToIgnore) {
            let value = issuesToIgnore[key];
            fs_1.writeFileSync(IGNORE_FILE, "  " + key + ":\n", { flag: 'a' });
            for (let item of value) {
                fs_1.writeFileSync(IGNORE_FILE, "    - " + item + ":\n", { flag: 'a' });
                fs_1.writeFileSync(IGNORE_FILE, "        reason: transitive ignore\n", { flag: 'a' });
                fs_1.writeFileSync(IGNORE_FILE, "        expires: \'2100-01-01\'\n", { flag: 'a' });
            }
        }
    });
}
snykTransitiveIgnore();
//# sourceMappingURL=index.js.map