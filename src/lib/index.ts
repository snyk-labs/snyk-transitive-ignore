//export {}

//import 'source-map-support/register'
const args = require('minimist')(process.argv.slice(2))
import { readFileSync, writeFileSync } from 'fs'
import { Stream } from 'stream'
import * as debugLib from 'debug'
import { debugPort } from 'process';

const debug = debugLib('snyk:index');

const IGNORE_FILE = ".snyk_ignore"

interface ignoreRule {
    vulnId: string,
    path: string
}

function readStream(stream: Stream, encoding = "utf8") {
    return new Promise((resolve, reject) => {
        let data = "";
        
        stream.on("data", chunk => data += chunk);
        stream.on("end", () => resolve(data));
        stream.on("error", error => reject(error));
    });
}

function checkIgnoreListMatch(ignoreItems: string[], directDep: string) {
    // check for two types of matches
    // 1. when version is not specified in the ignore entry
    // 2. when version is specified in the ignore entry

    for (const ignoreItem of ignoreItems) {
        if (ignoreItem.length > 0) { 
            debug('ignore item: ' + ignoreItem)
            // if ignoreItem contains an @ symbol, compare for equality to directDep
            if (ignoreItem.includes('@') && !ignoreItem.startsWith('@')) {
                debug('ignore includes version')
                if (ignoreItem == directDep) {
                    debug(`${ignoreItem} matches ${directDep}`)
                    return true;
                }
            }
            // if ignoreItem does not contain an @symbol, compare for startsWith match
            // up to and including @ symbol (any version)
            else {
                debug('ignore does not include version')
                if (ignoreItem.includes('*') && !ignoreItem.startsWith('*')) {
                    debug('ignore includes *');
                    if (directDep.startsWith(ignoreItem.slice(0, -1))) {
                        debug(`${ignoreItem} matches ${directDep}`);
                        return true;
                    }
                }
                if (directDep.startsWith(ignoreItem.concat('@'))) {
                    debug(`${ignoreItem} matches ${directDep}`)
                    return true;
                }
            }
        }
    }
    return false
}

function writeIgnoreEntry(vuln: string, path: string, expires: string, reason: string) {
    let writeString: string = "ignore:\n" +
        "  " + vuln + ":\n" +
        "    - '" + path + "':\n" + 
        "        reason: " + reason + "\n" + 
        "        expires: " + expires + "\n"
    
    
    writeFileSync(IGNORE_FILE, writeString, { flag: 'a' })
    
}

async function snykTransitiveIgnore() {
  var inputFile: string = ""
  var fullPath: string = ""
  var ignoreRules: ignoreRule[] = []
  var nestingLevel: number = 1
  var ignorePath: string = ""

  writeFileSync(IGNORE_FILE, "#snyk ignore file generated by snyk-transitive-ignore", { flag: 'w' })

  if (args.f && typeof args.f !== 'boolean') {
    inputFile = args.f;
    var ignoreStrings: string[] = await readFileSync(inputFile).toString().split("\n");
    debug('ignore strings: ' + ignoreStrings);
  }
  else {
    console.log('input file not specified');
  }

  if (args.l && typeof args.l !== 'boolean') {
      debug(`setting nestingLevel to ${args.l}`)
    nestingLevel = args.l;
    //console.log(ignoreStrings);
  }

  debug(`nesting level -> ${nestingLevel}`)
  let projects: any = []
  await readStream(process.stdin).then(async function(data){
    if ((String(data)).startsWith('[')) {
      debug('-all-projects output detected')
      projects = JSON.parse(String(data))
    } else {
      debug('single project output detected')
      projects.push(JSON.parse(String(data)))
    }  
    
    for await (const project of projects) {
      for await (const vuln of project.vulnerabilities) {
        fullPath = ""
        
  
        debug(`vuln id ${vuln.id}`)
        debug(`from direct dep ${vuln.from[nestingLevel]}`)
  
        for await(const from of vuln.from) {
            if (fullPath != "") {
              fullPath += ` > ${from}`
            }
            else {
                fullPath = `${from}`
            }
        }
        debug(`full path ${fullPath}`)
        debug(`is ${vuln.from[nestingLevel]} in ignore list?`)
        if (checkIgnoreListMatch(ignoreStrings, vuln.from[nestingLevel])) {
            debug('checkIgnore: true')
            //await writeIgnoreEntry(vuln.id, vuln.from[1], "2100-01-01", "transitive ignore")
            if (nestingLevel > 1) {
                //build ignore path
                ignorePath = "" 
                var i: number =1
                while (i < nestingLevel) {
                  ignorePath = ignorePath + vuln.from[i] + " > " + vuln.from[i+1]
                  i++
                }
            }
            else { ignorePath = vuln.from[1] }
            ignoreRules.push(
                {
                  vulnId: vuln.id,
                  //path: vuln.from[nestingLevel]
                  path: ignorePath
                }
            )
        }
  
      }
    }
    //console.log('ignore rules: ' + ignoreRules)

    interface IssueDictionary {
        [index: string]: string[];
    }
   var issuesToIgnore = {} as IssueDictionary;
   
    for await (const ignoreRule of ignoreRules) {
        debug(ignoreRule.vulnId)  
        debug(ignoreRule.path)
        if (issuesToIgnore[ignoreRule.vulnId]) {
            if (!issuesToIgnore[ignoreRule.vulnId].includes(ignoreRule.path)) {
                issuesToIgnore[ignoreRule.vulnId].push(ignoreRule.path)
            }
        }
        else {
            issuesToIgnore[ignoreRule.vulnId] = [ignoreRule.path]
        }
    }
    console.log('issues to ignore:')
    console.log(issuesToIgnore)
    // loop through issuesToIgnore and write ignore Entries
    writeFileSync(IGNORE_FILE, "ignore:\n")
    for (let key in issuesToIgnore) {
        let value = issuesToIgnore[key]
        writeFileSync(IGNORE_FILE, "  " + key + ":\n", { flag: 'a' })
        for (let item of value) {
           writeFileSync(IGNORE_FILE, "    - " + item + ":\n", {flag: 'a' } )
           writeFileSync(IGNORE_FILE, "        reason: transitive ignore\n", {flag: 'a'} )
           writeFileSync(IGNORE_FILE, "        expires: \'2100-01-01\'\n", {flag: 'a'} )
        }
    }
  })   
}

snykTransitiveIgnore()
